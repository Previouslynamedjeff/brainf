#include <stdio.h>
#include <stdlib.h> 
#include <stdbool.h>
#include <sys/stat.h>
#include <string.h>

typedef struct node 
{
    char ins;
    long long int count;
    struct node *next;
} Node;

// iterate through the list with a pointer
#define for_each_node_ref(head, it) for (Node *it = head; it != NULL; it = it->next)

#define TAB_SIZE 4

bool file_exists (char *filename);

long long int parse_file(FILE *fp, long long int len, char *input); // filters bf code
void optimize(long long int len, char *input, Node *head); // optimizes bf code before writing

void write_file(FILE *fp, Node *head);
void write_tabs(FILE *fp, const unsigned int tab_count); // writes tabs to file in a single fprintf call

void free_list(Node *head); // note: also frees head of the list
void add_node(Node **_cur, char _ins, long long int _count); // note: moves cur


int main(int argc, char* argv[]) 
{
    // error checking for file
	if (argc != 2)
	{
		printf("Usage: '%s [file.bf]\n", argv[0]);
		return 1;
	}
    else if (!file_exists(argv[1]))
	{
		printf("Error: filename is wrong or does not exist (%s)\n", argv[1]);
		return 2;
	}
	
	FILE* rptr = fopen(argv[1], "r");
	if (rptr == NULL)
	{	
		printf("Error: file pointer NULL\n");
		return 3;
	}

    // get file length
    fseek(rptr, 0, SEEK_END);
	long long int length = ftell(rptr);
	fseek(rptr, 0, SEEK_SET); 

    if (length == 0)
    {
        printf("file empty\n");
        return -1;
    }

    char *input = (char *) malloc(length + 1);

    // update length to new filtered code
    length = parse_file(rptr, length, input);
    printf("parsed: %s\n", input);

    Node *head = (Node *) malloc(sizeof(Node));
    head->ins = 'x';
    head->count = 0;
    head->next = NULL;

    optimize(length, input, head);

    for_each_node_ref(head, it)
    {
        printf("%lld%c", it->count, it->ins);
    } printf("\n");


    int file_name_length = strlen(argv[1]);

    char *file_name = (char *) malloc(file_name_length * sizeof(char));

    for (int i = 0; i < file_name_length - 3; i++) file_name[i] = argv[1][i];
    
    // add file extension
    file_name[file_name_length - 3] = '.';
    file_name[file_name_length - 2] = 'c';
    file_name[file_name_length - 1] = '\0';

    FILE *wptr = fopen(file_name, "w");
    write_file(wptr, head->next);
    printf("%s written.\n", file_name);

    fclose(rptr);
    fclose(wptr);

    free(input);
    free(file_name);
    free_list(head);
    return 0;
}

// file_exists written by codebunny & Adam Liss @ https://stackoverflow.com/a/230070
bool file_exists(char *filename) 
{
	struct stat buffer;   
	return (stat(filename, &buffer) == 0);
}

long long int parse_file(FILE *fp, long long int length, char *input)
{
    char tmp;
    fread(&tmp, sizeof(char), 1, fp);
    long long int read_ind = 0;

    // warning: read_ind != i
    while (!feof(fp))
    {
        switch(tmp) 
        {
            case '+': // add
            case '-': // subtract
            case '>': // move right
            case '<': // move left
            case '.': // write char
            case ',': // read char
            case '[': // begin loop
            case ']': // end loop
                input[read_ind++] = tmp;
        }
        fread(&tmp, sizeof(char), 1, fp);
    }
    input[read_ind++] = '\0'; // add end-of-string char
    return read_ind;
}

void optimize(long long int length, char *input, Node *head) 
{
    Node *cur = head;

    char prev_ins = input[0];

    long long int prev_count = 1;

    for (int i = 1; i < length; i++) 
    {
        if (prev_ins != input[i])
        {
            add_node(&cur, prev_ins, prev_count);

            prev_count = 0;
        }

        prev_count++;
        prev_ins = input[i];
    }
}

void write_file(FILE *fp, Node *head)
{
    /*
     * implemented using an array instead of a pointer
     *
     * how: pointer becomes the index in an array
     * why: because I don't want to malloc space for a pointer
     * 
     * sorry I don't want to #include <stdlib.h> 
     * 
     * it's a bit more mental overhead I guess maybe I'll change it later
    */ 

    fprintf(fp, "// <Autogenerated>\n"
                "#include <stdio.h>\n"
                "\n"
                "typedef unsigned char byte;\n"
                "\n"
                "byte tape[30000] = {0};\n"
                "\n"
                "int main(void)\n"
                "{\n"
                "    int index = 0;\n"
                "    // START\n");

    // how many tabs to do inside the loops
    unsigned int layer = 0;

    for_each_node_ref(head, it) 
    {
        char ins = it->ins;
        long long int count = it->count;

        // indent lines
        if (ins == ']') write_tabs(fp, layer);
        else write_tabs(fp, layer + 1);

        switch(ins)
        {
            case '+':
            case '-': 
                if (count == 1) fprintf(fp, "tape[index]%c%c;\n", ins, ins); // -- or ++
                else fprintf(fp, "tape[index] %c= %lld;\n", ins, count); // -= or +=
                
                break;
            case '>': 
            case '<': 
                ins = (it->ins == '>') ? '+' : '-';

                if (count == 1) fprintf(fp, "index%c%c;\n", ins, ins); // -- or ++
                else fprintf(fp, "index %c= %lld;\n", ins, count); // -= or +=
                
                break;
            case '.': // write char
                for (long long int i = 0; i < count; i++)
                    fprintf(fp, "putc(tape[index], stdout);\n");
                break;
            case ',': // read char
                for (long long int i = 0; i < count; i++)
                    fprintf(fp, "tape[index] = getc(stdout);\n");
                break;
            case '[':
                for (int i = 0; i < count; i++)
                {
                    fprintf(fp, "while(tape[index])\n");
                    write_tabs(fp, layer + 1);
                    fprintf(fp, "{\n");
                    layer++;

                    if (i < count - 1) write_tabs(fp, layer + 1);
                }
                break;
            case ']':
                for (int i = 0; i < count; i++)
                {
                    fprintf(fp, "}\n");
                    layer--;

                    if (i < count - 1) write_tabs(fp, layer);
                }
                break;
        }
    }

    fprintf(fp, "     // END\n}");
}

void write_tabs(FILE *fp, const unsigned int tab_count)
{
    // note: unsure if it is faster to malloc or to call fprintf multiple times

    char *tabs = (char *) malloc((tab_count + 1) * sizeof(char));

    for (int i = 0; i < tab_count; i++) tabs[i] = ' ';
    tabs[tab_count] = '\0';


    for (int i = 0; i < TAB_SIZE; i++)
        fprintf(fp, "%s", tabs);

    free(tabs);
}

void free_list(Node *head) 
{
    Node *cur = head;

    // todo: is it cur != NULL or cur->next != NULL 
    while(cur != NULL)
    {
        Node *tmp = cur;
        cur = cur->next;
        free(tmp);
    }
}

void add_node(Node **_cur, char _ins, long long int _count)
{
    Node *tmp = (Node *) malloc(sizeof(Node));

    if (tmp == NULL)
    {
        printf("Error allocating node for list (0x%p)\n", tmp);
        exit(-1);
    }
    // create next node
    tmp->count = _count;
    tmp->ins = _ins;

    // attach node to list
    (*_cur)->next = tmp;

    // move cur to next in list
    *_cur = (*_cur)->next;
}
