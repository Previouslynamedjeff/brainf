#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <string.h>

typedef struct node
{
    char ins;
    long long int count;
    struct node *next;
} Node;

#define THROW_IF(cond, code, ...) if(cond) { printf(__VA_ARGS__); exit(code); }

#define TAB_SIZE 4

#define write_tabs(fp, tab_count) for (int i = 0; i < TAB_SIZE * (tab_count); i++) fputc(' ', fp)

// iterate through the list with a pointer
#define for_each_node_ref(head, it) for (Node *it = head; it != NULL; it = it->next)


bool file_exists (char *filename);

long long int parse_file(FILE *fp, char *input); // filters out unrelated characters
void optimize(long long int len, char *input, Node *head); // groups commands together

void write_file(FILE *fp, Node *head);

void free_list(Node *head); // note: also frees head of the list
void add_node(Node **_cur, char _ins, long long int _count); // note: moves cur


int main(int argc, char* argv[])
{
    // error checking for file
    THROW_IF(argc != 2, 1,
            "Usage: '%s [file.bf]\n", argv[0]);
    THROW_IF(!file_exists(argv[1]), 2,
            "Error: filename is wrong or does not exist (%s)\n", argv[1]);

	FILE* rptr = fopen(argv[1], "r");

    THROW_IF(rptr == NULL, 3,
            "Error: file pointer NULL (%s)\n", argv[1]);

    // get file length
    fseek(rptr, 0, SEEK_END);
	long long int length = ftell(rptr);
	fseek(rptr, 0, SEEK_SET);

    THROW_IF(length == 0, EXIT_FAILURE,
            "Error: file is empty (%s)\n", argv[1]);

    char *input = (char *) malloc(length + 1);

    // update length to new filtered code
    length = parse_file(rptr, input);

    Node *head = (Node *) malloc(sizeof(Node));
    *head = (Node) {
        .ins = 'x',
        .count = 0,
        .next = NULL
    };

    optimize(length, input, head);

    int f_name_len = strlen(argv[1]);
    char *f_name = (char *) malloc(f_name_len);

    // add file base
    strncpy(f_name, argv[1], f_name_len - 2);

    // add file extension
    strcpy((f_name + f_name_len - 2), "c");

    FILE *wptr = fopen(f_name, "w");
    THROW_IF(wptr == NULL, 3, "Error: file pointer NULL (%s)\n", f_name);

    write_file(wptr, head->next);
    printf("%s written successfully.\n", f_name);

    // exit program
    fclose(rptr);
    fclose(wptr);

    free(input);
    free(f_name);
    free_list(head);

    return 0;
}

// file_exists written by codebunny & Adam Liss @ https://stackoverflow.com/a/230070
bool file_exists(char *filename)
{
	struct stat buffer;
	return (stat(filename, &buffer) == 0);
}

long long int parse_file(FILE *fp, char *input)
{
    char tmp;
    long long int read_ind = 0;

    while((tmp = fgetc(fp)) != EOF)
    {
        // me when i am falling through cases
        switch(tmp)
        {
            case '+': // add
            case '-': // subtract
            case '>': // move right
            case '<': // move left
            case '.': // write char
            case ',': // read char
            case '[': // begin loop
            case ']': // end loop
                input[read_ind++] = tmp;
        }
    }

    input[read_ind++] = '\0'; // add end-of-string char
    return read_ind;
}

void optimize(long long int length, char *input, Node *head)
{
    Node *cur = head;
    long long int prev_count = 1;

    for (long long int i = 1; i < length; i++)
    {
        if (input[i - 1] != input[i])
        {
            add_node(&cur, input[i - 1], prev_count);
            prev_count = 0;
        }
        prev_count++;
    }
}

void write_file(FILE *fp, Node *head)
{
    /*
     *  implemented using an array instead of a pointer
     *
     *  how: pointer becomes the index in an array
     *  why: because I don't want to malloc space for a pointer
     *
     *  sorry I don't want to #include <stdlib.h>
     */

    // how many tabs to do inside the loops
    unsigned int layer = 0;

    // pre-written comamnds
    char *text[4] = {
        "putchar(tape[index]);\n",
        "tape[index] = getchar();\n",
        "while(tape[index]) {\n",
        "}\n"
    };

    // how much to change the layer by
    int layer_off;

    fprintf(fp, "// <Autogenerated>\n"
                "#include <stdio.h>\n"
                "\n"
                "typedef unsigned char byte;\n"
                "\n"
                "byte tape[30000] = {0};\n"
                "\n"
                "int main(void)\n"
                "{\n"
                "    int index = 0;\n"
                "    // START\n");

    for_each_node_ref(head, it)
    {
        char ins = it->ins;
        long long int count = it->count;

        // index of text to choose
        int text_index = -1;

        // indent lines
        if (ins == ']') write_tabs(fp, layer);
        else write_tabs(fp, layer + 1);

        switch(ins)
        {
            case '+':
            case '-':
                if (count == 1)
                    fprintf(fp, "tape[index]%c%c;\n", ins, ins); // -- or ++
                else
                    fprintf(fp, "tape[index] %c= %lld;\n", ins, count); // -= or +=
                break;
            case '>':
            case '<':
                char tmp = (ins == '>') ? '+' : '-';

                if (count == 1)
                    fprintf(fp, "index%c%c;\n", tmp, tmp); // -- or ++
                else
                    fprintf(fp, "index %c= %lld;\n", tmp, count); // -= or +=
                break;
            case '.':
                text_index = 0;
                layer_off = 0;
                break;
            case ',':
                text_index = 1;
                layer_off = 0;
                break;
            case '[':
                text_index = 2;
                layer_off = 1;
                break;
            case ']':
                text_index = 3;
                layer_off = -1;
                break;
        }

        if (text_index != -1)
        {   
            for (long long int i = 0; i < count; i++)
            {
                fprintf(fp, "%s", text[text_index]);
                layer = layer + layer_off;
                if (i < count - 1) write_tabs(fp, layer + (layer_off >= 0));
            }
        }
    }

    fprintf(fp, "    // END\n"
                "    return 0;\n"
                "}");
}


void free_list(Node *head)
{
    Node *cur = head;

    while(cur != NULL)
    {
        Node *tmp = cur;
        cur = cur->next;
        free(tmp);
    }
}

void add_node(Node **_cur, char _ins, long long int _count)
{
    Node *tmp = (Node *) malloc(sizeof(Node));

    THROW_IF(tmp == NULL, EXIT_FAILURE,
            "Error allocating node for list (0x%p)\n", tmp);

    // create next node
    *tmp = (Node) {
        .ins = _ins,
        .count = _count,
        .next = NULL
    };

    // attach node to list
    (*_cur)->next = tmp;

    // move cur to next in list
    *_cur = (*_cur)->next;
}
